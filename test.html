<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js.txt webgl - geometry - terrain + fog</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info"><a href="http://github.com/mrdoob/three.js" target="_blank">three.js.txt</a> - webgl terrain + fog demo <br />(left click: forward, right click: backward)</div>

		<script src="js/libs/three.min.js"></script>

		<script src="js/libs/ImprovedNoise.js"></script>

		<script src="js/libs/Detector.js"></script>
		<script src="js/libs/Stats.js"></script>

		<script>

			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;

			var camera, controls, scene, renderer;

			var cube, cube2, mesh, texture, light;

			var worldWidth = 256, worldDepth = 256,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var clock = new THREE.Clock();

			init();
			animate();

            function init() {
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );

				scene = new THREE.Scene();
				
				//scene.fog = new THREE.FogExp2( 0xffffff, 0.0005 );
				
				controls = new TestControls( camera, document );
				controls.lookSpeed = 0;
				
/*
				controls = new THREE.FirstPersonControls( camera );
				controls.movementSpeed = 1000;
				controls.lookSpeed = 0.1;
*/

				data = generateHeight( worldWidth, worldDepth );

				camera.position.y = data[ worldHalfWidth + worldHalfDepth * worldWidth ] + 500;

				var geometry = new THREE.PlaneGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1 );
				geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

				for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {

					geometry.vertices[ i ].y = data[ i ] * 5;

				}


                /*texture = new THREE.Texture( generateTexture( data, worldWidth, worldDepth ), new THREE.UVMapping(), THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping );
				texture.needsUpdate = true;

				mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );
				*/
				mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0xddc09f, shading: THREE.SmoothShading } ) );
                // enable shadows for an object
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                //scene.add( mesh );
                
                cube =  new THREE.Mesh(new THREE.CubeGeometry(500,500,500), new THREE.MeshPhongMaterial({color: 0xffffff}));
                cube.position.x = 1000;
                cube.position.y = 300;
                // enable shadows for an object
                cube.castShadow = true;
                scene.add(cube);
                
                
                //  GROUND
				/*var gt = THREE.ImageUtils.loadTexture( "img/grasslight-big.jpg" );
				var gg = new THREE.PlaneGeometry( 16000, 16000 );
				var gm = new THREE.MeshLambertMaterial( { color: 0xffffff, map: gt, perPixel: true } );

				var water = new THREE.Mesh( gg, gm );
				water.rotation.x = - Math.PI / 2;
				water.material.map.repeat.set( 64, 64 );
				water.material.map.wrapS = water.material.map.wrapT = THREE.RepeatWrapping;
				water.receiveShadow = true;*/
				
			

				var geometry = new THREE.PlaneGeometry( 100, 100 );
				var planeMaterial = new THREE.MeshPhongMaterial( { color: 0xffdd99 } );
				THREE.ColorUtils.adjustHSV( planeMaterial.color, 0, 0, 0.9 );
				planeMaterial.ambient = planeMaterial.color;

				var ground = new THREE.Mesh( geometry, planeMaterial );

				ground.position.set( 0, 0, 0 );
				ground.rotation.x = - Math.PI / 2;
				ground.scale.set( 100, 100, 100 );

				ground.castShadow = false;
				ground.receiveShadow = true;

				scene.add( ground );
				
				// Light
                scene.add( new THREE.AmbientLight( 0x404040 ) );

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 1, 0 );
				scene.add( light );


				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
                
                
				container.innerHTML = "";

				container.appendChild( renderer.domElement );
                renderer.shadowMapEnabled = true;
                renderer.shadowMapCascade = true;
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

            /*
			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );

				controls = new THREE.FirstPersonControls( camera );
				controls.movementSpeed = 150;
				controls.lookSpeed = 0.1;

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0xffffff, 0.0025 );


				data = generateHeight( worldWidth, worldDepth );

				camera.position.y = data[ worldHalfWidth + worldHalfDepth * worldWidth ] * 10 + 500;

				var geometry = new THREE.PlaneGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1 );
				geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

				for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {

					geometry.vertices[ i ].y = data[ i ] * 10;

				}

				texture = new THREE.Texture( generateTexture( data, worldWidth, worldDepth ), new THREE.UVMapping(), THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping );
				texture.needsUpdate = true;

				mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );

				
				scene.add( mesh );
                                
                var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
                directionalLight.position.set( 1, 0, 0 );
                directionalLight.castShadow = true;
                scene.add( directionalLight );
                
				renderer = new THREE.WebGLRenderer( { clearColor: 0xffffff, clearAlpha: 1 } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );


				window.addEventListener( 'resize', onWindowResize, false );

			}*/

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

			}

			function generateHeight( width, height ) {

				var size = width * height, data = new Float32Array( size ),
				perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

				for ( var i = 0; i < size; i ++ ) {

					data[ i ] = 0

				}

				for ( var j = 0; j < 4; j ++ ) {

					for ( var i = 0; i < size; i ++ ) {

						var x = i % width, y = ~~ ( i / width );
						data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );


					}

					quality *= 5;

				}

				return data;

			}

			function generateTexture( data, width, height ) {

				var canvas, canvasScaled, context, image, imageData,
				level, diff, vector3, sun, shade;

				vector3 = new THREE.Vector3( 0, 0, 0 );

				sun = new THREE.Vector3( 1, 1, 1 );
				sun.normalize();

				canvas = document.createElement( 'canvas' );
				canvas.width = width;
				canvas.height = height;

				context = canvas.getContext( '2d' );
				context.fillStyle = '#000';
				context.fillRect( 0, 0, width, height );

				image = context.getImageData( 0, 0, canvas.width, canvas.height );
				imageData = image.data;

				for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

					vector3.x = data[ j - 2 ] - data[ j + 2 ];
					vector3.y = 2;
					vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
					vector3.normalize();

					shade = vector3.dot( sun );

					imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );
					imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
					imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );

				}

				context.putImageData( image, 0, 0 );

				// Scaled 4x

				canvasScaled = document.createElement( 'canvas' );
				canvasScaled.width = width * 4;
				canvasScaled.height = height * 4;

				context = canvasScaled.getContext( '2d' );
				context.scale( 4, 4 );
				context.drawImage( canvas, 0, 0 );

				image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
				imageData = image.data;

				for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

					var v = ~~ ( Math.random() * 5 );

					imageData[ i ] += v;
					imageData[ i + 1 ] += v;
					imageData[ i + 2 ] += v;

				}

				context.putImageData( image, 0, 0 );

				return canvasScaled;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

                //directionalLight.position.z++;

				render();
				stats.update();

			}


			function render() {

				controls.update( clock.getDelta() );
				renderer.render( scene, camera );

			}
			
			
			
			
			/**
    
             */
            
            function TestControls( object, domElement ) {
            
                this.object = object;
                this.target = new THREE.Vector3( 0, 0, 0 );
            
                this.domElement = ( domElement !== undefined ) ? domElement : document;
            
                this.movementSpeed = 1000;
                this.lookSpeed = 0.005;
            
                this.lookVertical = true;
                this.autoForward = false;
                // this.invertVertical = false;
            
                this.activeLook = false;
            
                this.heightSpeed = false;
                this.heightCoef = 1.0;
                this.heightMin = 0.0;
                this.heightMax = 1.0;
            
                this.constrainVertical = false;
                this.verticalMin = 0;
                this.verticalMax = Math.PI;
            
                this.autoSpeedFactor = 0.0;
            
                this.mouseX = 0;
                this.mouseY = 0;
            
                this.lat = 0;
                this.lon = 0;
                this.phi = 0;
                this.theta = 0;
            
                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;
                this.rotateLeft = false;
                this.rotateRight = false;
                this.freeze = false;
            
                this.mouseDragOn = false;
            
                this.viewHalfX = 0;
                this.viewHalfY = 0;
            
                if ( this.domElement !== document ) {
            
                    this.domElement.setAttribute( 'tabindex', -1 );
            
                }
            
                //
            
                this.handleResize = function () {
            
                    if ( this.domElement === document ) {
            
                        this.viewHalfX = window.innerWidth / 2;
                        this.viewHalfY = window.innerHeight / 2;
            
                    } else {
            
                        this.viewHalfX = this.domElement.offsetWidth / 2;
                        this.viewHalfY = this.domElement.offsetHeight / 2;
            
                    }
            
                };
            
                this.onMouseDown = function ( event ) {
            
                    if ( this.domElement !== document ) {
            
                        this.domElement.focus();
            
                    }
            
                    event.preventDefault();
                    event.stopPropagation();
            
                    if ( this.activeLook ) {
            
                        switch ( event.button ) {
            
                            case 0: this.moveForward = true; break;
                            case 2: this.moveBackward = true; break;
            
                        }
            
                    }
            
                    this.mouseDragOn = true;
            
                };
            
                this.onMouseUp = function ( event ) {
            
                    event.preventDefault();
                    event.stopPropagation();
            
                    if ( this.activeLook ) {
            
                        switch ( event.button ) {
            
                            case 0: this.moveForward = false; break;
                            case 2: this.moveBackward = false; break;
            
                        }
            
                    }
            
                    this.mouseDragOn = false;
            
                };
            
                this.onMouseMove = function ( event ) {
            
                    if ( this.domElement === document ) {
            
                        this.mouseX = event.pageX - this.viewHalfX;
                        this.mouseY = event.pageY - this.viewHalfY;
            
                    } else {
            
                        this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
                        this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;
            
                    }
            
                };
            
                this.onKeyDown = function ( event ) {
            
                    //event.preventDefault();
            
                    switch ( event.keyCode ) {
            
                        case 38: /*up*/
                        case 87: /*W*/ this.moveForward = true; break;
            
                        case 37: /*left*/
                        case 65: /*A*/ this.moveLeft = true; break;
            
                        case 40: /*down*/
                        case 83: /*S*/ this.moveBackward = true; break;
            
                        case 39: /*right*/
                        case 68: /*D*/ this.moveRight = true; break;
            
                        case 82: /*R*/ this.moveUp = true; break;
                        case 70: /*F*/ this.moveDown = true; break;
           
                        case 81: /* Q */ this.rotateLeft = true; break;
                        case 69: /* E */ this.rotateRight = true; break;

                    }
            
                };
            
                this.onKeyUp = function ( event ) {
            
                    switch( event.keyCode ) {
            
                        case 38: /*up*/
                        case 87: /*W*/ this.moveForward = false; break;
            
                        case 37: /*left*/
                        case 65: /*A*/ this.moveLeft = false; break;
            
                        case 40: /*down*/
                        case 83: /*S*/ this.moveBackward = false; break;
            
                        case 39: /*right*/
                        case 68: /*D*/ this.moveRight = false; break;
            
                        case 82: /*R*/ this.moveUp = false; break;
                        case 70: /*F*/ this.moveDown = false; break;
                        
                        case 81: /* Q */ this.rotateLeft = false; break;
                        case 69: /* E */ this.rotateRight = false; break;
            
                    }
            
                };
            
                this.update = function( delta ) {
                    var actualMoveSpeed = 0;
            
                    if ( this.freeze ) {
            
                        return;
            
                    } else {
            
                        if ( this.heightSpeed ) {
            
                            var y = THREE.Math.clamp( this.object.position.y, this.heightMin, this.heightMax );
                            var heightDelta = y - this.heightMin;
            
                            this.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );
            
                        } else {
            
                            this.autoSpeedFactor = 0.0;
            
                        }
            
                        actualMoveSpeed = delta * this.movementSpeed;
            
                        if ( this.moveForward || ( this.autoForward && !this.moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) );
                        if ( this.moveBackward ) this.object.translateZ( actualMoveSpeed );
            
                        if ( this.moveLeft ) this.object.translateX( - actualMoveSpeed );
                        if ( this.moveRight ) this.object.translateX( actualMoveSpeed );
            
                        if ( this.moveUp ) this.object.translateY( actualMoveSpeed );
                        if ( this.moveDown ) this.object.translateY( - actualMoveSpeed );
            
                        var actualLookSpeed = delta * this.lookSpeed;
            
                        if ( !this.activeLook ) {
            
                            actualLookSpeed = 0;
            
                        }
                        
                        
                        if ( this.rotateLeft ) this.lon -= actualMoveSpeed/10;
                        if ( this.rotateRight ) this.lon += actualMoveSpeed/10;
                        
                        /*
                        this.lon += this.mouseX * actualLookSpeed;
                        if( this.lookVertical ) this.lat -= this.mouseY * actualLookSpeed; // * this.invertVertical?-1:1;
                        */
                        this.lat = Math.max( - 85, Math.min( 85, this.lat ) );
                        this.phi = ( 90 - this.lat ) * Math.PI / 180;
                        this.theta = this.lon * Math.PI / 180;
            
                        var targetPosition = this.target,
                            position = this.object.position;
            
                        targetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );
                        targetPosition.y = position.y + 100 * Math.cos( this.phi );
                        targetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );
            
                    }
            
                    var verticalLookRatio = 1;
            
                    if ( this.constrainVertical ) {
            
                        verticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );
            
                    }
            
                    this.lon += this.mouseX * actualLookSpeed;
                    if( this.lookVertical ) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;
            
                    this.lat = Math.max( - 85, Math.min( 85, this.lat ) );
                    this.phi = ( 90 - this.lat ) * Math.PI / 180;
            
                    this.theta = this.lon * Math.PI / 180;
            
                    if ( this.constrainVertical ) {
            
                        this.phi = THREE.Math.mapLinear( this.phi, 0, Math.PI, this.verticalMin, this.verticalMax );
            
                    }
            
                    var targetPosition = this.target,
                        position = this.object.position;
            
                    targetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );
                    targetPosition.y = position.y + 100 * Math.cos( this.phi );
                    targetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );
            
                    this.object.lookAt( targetPosition );
            
                };
            
            
                this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
            
                this.domElement.addEventListener( 'mousemove', bind( this, this.onMouseMove ), false );
                this.domElement.addEventListener( 'mousedown', bind( this, this.onMouseDown ), false );
                this.domElement.addEventListener( 'mouseup', bind( this, this.onMouseUp ), false );
                this.domElement.addEventListener( 'keydown', bind( this, this.onKeyDown ), false );
                this.domElement.addEventListener( 'keyup', bind( this, this.onKeyUp ), false );
            
                function bind( scope, fn ) {
            
                    return function () {
            
                        fn.apply( scope, arguments );
            
                    };
            
                };
            
                this.handleResize();
            
            };


		</script>

	</body>
</html>
